#lang racket/base

(define (abs n)
  (if (< n 0) (- n) n))
(define (abs-cond n)
  (cond ((< n 0) (- n))
        ((> n 0) n)
        ((= n 0) 0)))
(define (sign n)
  (cond ((> n 0) 1)
        ((= n 0) 0)
        (else -1)))
(define (max x y)
  (if (> y x) y x))
(define (min x y)
  (if (< y x) y x))
(define (between? x low high)
  (if (and (>= x low) (<= x high)) "t" "f"))
(define (divisible? a b)
  (if (= (modulo a b) 0) "t" "f"))
(define (quadrant x y)
  (cond ((and (> x 0) (> y 0)) "I")
        ((and (< x 0) (> y 0)) "II")
        ((and (< x 0) (< y 0)) "III")
        ((and (> x 0) (< y 0)) "IV")
        (else "axis")))
(define (odd? n)
  (cond ((= (modulo n 2) 1) #t)
  (else #f)))
(define (even? n)
  (not (odd? n)))
(define (leap-year? year)
  (cond ((= (modulo year 400) 0) "leap")
        ((= (modulo year 100) 0) "not leap")
        ((= (modulo year 4) 0) "leap")
        (else "not leap")
        ))
(define (factorial n)
  (if (<= n 0)
      1
      (* n (factorial (- n 1)))))
(define (sum-to-n n)
  (if (= n 0)
      0
      (+ n (sum-to-n (- n 1)))))
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))
(define (power b n)
  (cond ((= n 0) 1)
        ((= n 1) b)
        ((< n 0) (/ 1 (* b (power b (- 0 n)))))
        (else (* b (power b (- n 1))))))
(define (square x)
  (* x x))
(define (improve guess x)
  (average guess (/ x guess)))
(define (average x y)
  (/ (+ x y) 2))
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (sqrt x)
  (sqrt-iter 1.0 x))
(define (max-2 x y)
  (cond ((> x y) x)
        (else y)))
(define (three-way-compare a b)
  (cond ((> a b) "greater")
        ((< a b) "less")
        (else "equal")))
(define (clamp n low high)
  (n low high))
(define (odd?-2 n)
  (cond ((= (modulo n 2) 1) "odd")))
(define (nonzero? n)
  (cond ((= n 0) #f)
        (else #t)))
 